#!/usr/bin/env python

import argparse
import subprocess
import sys
from xml.etree import ElementTree

import yaml


def main():
    with open('.cardboardlint.yml') as fh:
        config = yaml.load(fh)

    args = parse_args()
    files_lines = run_diff(args.refspec)

    if args.selection is None:
        config_linters = config['linters']
    else:
        config_linters = {args.selection: config['linters'][args.selection]}

    retcode = 0
    for lintname, lintconfig in config_linters.items():
        messages = [message for message in LINTERS[lintname](lintconfig, files_lines)
                    if message.indiff(files_lines)]
        if len(messages) > 0:
            retcode = -1
        for message in messages:
            print(message)
    sys.exit(retcode)


def parse_args():
    parser = argparse.ArgumentParser('cardboardlint')
    parser.add_argument('refspec', help='The parent commit used to compute the diff.')
    # The next argument should become a lot smarter in future, e.g. select all static or
    # dynamic linters, or a fraction of them, e.g. "dynamic 0%-33%".
    parser.add_argument('selection', nargs='?', default=None, help='Run just the given linter.')
    return parser.parse_args()


def run_diff(refspec_parent):
    command = ['git', 'diff', '-U0', refspec_parent]
    diff_output = subprocess.check_output(command)

    files_lines = {}
    current_filename = None
    for line in diff_output.splitlines():
        if line.startswith('+++ b/'):
            current_filename = line[6:]
        elif line.startswith('@@ '):
            added_str = line.split()[2]
            if added_str.count(',') == 1:
                offset, nlines = added_str.split(',')
                line_numbers = set(range(int(offset), int(offset) + int(nlines) + 1))
            else:
                offset = int(int(added_str))
                line_numbers = set([offset])
            all_line_numbers = files_lines.setdefault(current_filename, set([]))
            all_line_numbers |= line_numbers
    return files_lines


class Message(object):
    """Error message and meta information.

    This class contains all the machinery that the trapdoor driver uses to decide if
    a message is new or not. When a context is available, it is used to compare two
    messages instead of line numbers. If not, the line numbers are used. Line numbers are
    a relatively poor descriptor for assessing if a message is new in a feature branch.
    For example, lines may have been inserted or removed, which changes the line numbers
    without actually changing any code.
    """

    def __init__(self, filename, lineno, charno, text, context=None):
        """Initialize a message.

        Parameters
        ----------
        filename : str
                   The filename for which the message is reported.
        lineno : int (or None)
                 The line number at which the error is reported, if any.
        charno : int (or None)
                 The character position at which the error is reported, if any.
        text : str
               A description of the problem.
        context : str
                  A string that (almost) uniquely identifies the location of the error
                  without using line numbers.
        """
        if lineno is not None and not isinstance(lineno, int):
            raise TypeError('When given, lineno must be integer.')
        if charno is not None and not isinstance(charno, int):
            raise TypeError('When given, charno must be integer.')
        self._filename = filename
        self._lineno = lineno
        self._charno = charno
        self._text = text
        self._context = context

    filename = property(lambda self: self._filename)
    lineno = property(lambda self: self._lineno)
    charno = property(lambda self: self._charno)
    text = property(lambda self: self._text)
    context = property(lambda self: self._context)

    def __eq__(self, other):
        """Test if self is equal to other."""
        # First come the usualy things for comparisons...
        equal = self.__class__ == other.__class__ \
            and self._filename == other._filename \
            and self._charno == other._charno \
            and self._text == other._text \
            and self._context == other._context
        if not equal:
            return False
        # If still equal, then only use line numbers if no context is available.
        if self._context is None and other._context is None:
            return self._lineno == other._lineno
        return True

    def __hash__(self):
        """Return a fast hash.

        The hash only includes the lineno if no context is present. If a context is
        present, it is used instead and the line number is not included in the hash. This
        convention is compatible with the code in __eq__.
        """
        if self._context is None:
            return hash((self._filename, self._lineno, self._charno, self._text))
        else:
            return hash((self._filename, self._charno, self._text, self._context))

    def __lt__(self, other):
        """Test if self is less than other."""
        if self.__class__ != other.__class__:
            return self < other
        tup_self = (self._filename, self._lineno, self._charno, self._text, self._context)
        tup_other = (other._filename, other._lineno, other._charno, other._text, other._context)
        return tup_self < tup_other

    def add_context(self, context):
        """Return an identical message with context."""
        if self._context is not None:
            raise ValueError('This message already has context.')
        return Message(self._filename, self._lineno, self._charno, self._text, context)

    def __str__(self):
        """Return a nicely formatted string representation of the message."""
        # Fix the location string
        if self.filename is None:
            location = '(nofile)            '
        else:
            location = str(self.filename)
            if self.lineno is not None:
                location += '%6i' % self.lineno
            else:
                location += ' '*6
            if self.charno is not None:
                location += '%6i' % self.charno
            else:
                location += ' '*6
        return '%70s   %s' % (location, self.text)

    def indiff(self, files_lines):
        line_numbers = files_lines.get(self._filename)
        if line_numbers is not None:
            return self._lineno in line_numbers
        return False


def run_command(command, verbose=True, cwd=None, has_failed=None):
    """Run command as subprocess with default settings suitable for trapdoor scripts.

    Parameters
    ----------
    command : list of str
              The command argument to be passed to Popen.
    verbose : bool
              When set to False, the command will not be printed on screen.
    cwd : str
          The working directory where the command is executed.
    has_failed : function(returncode, stdout, stderr)
                 A function that determines if the subprocess has failed. The default
                 behavior is to check for a non-zero return code.

    Returns
    -------
    output : (str, str)
             if Sucessful, the output collected from stdout and stderr are returned.

    Raises
    ------
    In case the subprocess returns a non-zero exit code, the stdout and stderr are printed
    on screen and RuntimeError is raised.
    """
    # Functions to detect failure
    def default_has_failed(returncode, stdout, stderr):
        """Default function to detect failed subprocess."""
        return returncode != 0
    if has_failed is None:
        has_failed = default_has_failed

    if verbose:
        print 'RUNNING            :', ' '.join(command)
    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
    stdout, stderr = proc.communicate()
    if has_failed(proc.returncode, stdout, stderr):
        print 'STDOUT'
        print '------'
        print stdout
        print 'STDERR'
        print '------'
        print stderr
        raise RuntimeError('Subprocess returned non-zero exit status %i' % proc.returncode)
    else:
        return stdout, stderr


def linter_cppcheck(lintconfig, files_lines):
    # Get version
    command = ['cppcheck', '--version']
    print 'USING VERSION      :', run_command(command, verbose=False)[0].strip()

    # Get the cpp filenames
    filenames = [filename for filename in files_lines
                 if filename[filename.rfind('.'):] in ['.h', '.h.in', '.cpp', '.c']]

    messages = set([])
    if len(filenames) > 0:
        # Call Cppcheck
        command = ['cppcheck'] + filenames + ['-q', '--enable=all', '--language=c++',
                   '--std=c++11', '--xml', '--suppress=missingIncludeSystem',
                   '--suppress=unusedFunction']
        xml_str = run_command(command)[1]
        etree = ElementTree.fromstring(xml_str)

        # Parse the output of Cppcheck into standard return values
        for error in etree:
            if 'file' not in error.attrib:
                continue
            key = '%15s  %40s  %30s' % (
                error.attrib['severity'],
                error.attrib['file'].ljust(40),
                error.attrib['id'].ljust(30),
            )
            text = '%s %s %s' % (error.attrib['severity'], error.attrib['id'], error.attrib['msg'])
            messages.add(Message(error.attrib['file'], int(error.attrib['line']),
                                 None, text))
    return messages



LINTERS = {
    'cppcheck': linter_cppcheck
}


if __name__ == '__main__':
    main()
