#!/usr/bin/env python

import argparse
import subprocess
import sys
from xml.etree import ElementTree

import yaml


def main():
    # get arguments
    args = parse_args()

    # get git diff
    files_lines = run_diff(args.refspec)

    # load lint configuration for module
    with open('.cardboardlint.yml') as fh:
        config = yaml.load(fh)

    # select specific linter if desired
    if args.selection is None:
        config_linters = config['linters']
    else:
        config_linters = {args.selection: config['linters'][args.selection]}

    returncode = 0
    for lintname, lintconfig in config_linters.items():
        messages = [message for message in LINTERS[lintname](lintconfig, files_lines)
                    if message.indiff(files_lines)]
        if len(messages) > 0:
            returncode = -1
        for message in messages:
            print(message)
    sys.exit(returncode)


def parse_args():
    """Parse the arguments given to the script."""
    parser = argparse.ArgumentParser(prog='cardboardlint')
    parser.add_argument('refspec', help='The parent commit used to compute the diff.')
    # The next argument should become a lot smarter in future, e.g. select all static or
    # dynamic linters, or a fraction of them, e.g. "dynamic 0%-33%".
    parser.add_argument('selection', nargs='?', default=None, help='Run just the given linter.')
    return parser.parse_args()


def run_diff(refspec_parent):
    """Run git diff with respect to current branch

    Parameters
    ----------
    refspec_parent : str
        Reference to the parent branch

    Returns
    -------
    files_lines : dict
        Dictionary of filename to the set of line numbers (that have been modified)
    """
    # generate 0 lines of context (i.e. only the lines that differ)
    # FIXME: gitpython?
    command = ['git', 'diff', '-U0', refspec_parent]
    diff_output = subprocess.check_output(command)

    # parse git diff output
    files_lines = {}
    current_filename = None
    for line in diff_output.splitlines():
        if line.startswith('+++ b/'):
            current_filename = line[6:]
        elif line.startswith('@@ '):
            added_str = line.split()[2]
            # multiple lines added/modified
            if added_str.count(',') == 1:
                offset, nlines = added_str.split(',')
                line_numbers = set(range(int(offset), int(offset) + int(nlines) + 1))
            # single line added/modified
            else:
                offset = int(added_str)
                line_numbers = set([offset])
            # store line numbers
            files_lines.setdefault(current_filename, set()).update(line_numbers)
    return files_lines


class Message(object):
    """Error message and meta information.

    This class contains all the machinery that the trapdoor driver uses to check for new messages.
    When a context is available, it is used to compare two messages instead of line numbers. If not,
    the line numbers are used. Line numbers are a relatively poor descriptor for assessing if a
    message is new. For example, lines may have been inserted or removed, which changes the line
    numbers without actually changing any of the code.
    """

    def __init__(self, filename, lineno, charno, text, context=None):
        """Initialize a message.

        Parameters
        ----------
        filename : str
            The filename from which the message is reported.
        lineno : int (or None)
            The line number at which the error/problem is reported.
            None if no error/problem is reported.
        charno : int (or None)
            The character position at which the error/problem is reported.
            None if no error/problem is reported.
        text : str
            A description of the error/problem.
        context : str
            A string that (almost) uniquely identifies the location of the error without using line
            numbers.
        """
        if lineno is not None and not isinstance(lineno, int):
            raise TypeError('`lineno` must be an integer or None')
        if charno is not None and not isinstance(charno, int):
            raise TypeError('`charno` must be an integer or None')
        # FIXME: is it necessary for these attributes to be private?
        self._filename = filename
        self._lineno = lineno
        self._charno = charno
        self._text = text
        self._context = context

    @property
    def filename(self):
        return self._filename

    @property
    def lineno(self):
        return self._lineno

    @property
    def charno(self):
        return self._charno

    @property
    def text(self):
        return self._text

    @property
    def context(self):
        return self._context

    def __eq__(self, other):
        """Test if two Message's are equal."""
        # First come the usualy things for comparisons...
        if not (self.__class__ == other.__class__
                and self._filename == other._filename
                and self._charno == other._charno
                and self._text == other._text
                and self._context == other._context):
            return False
        # If still equal, then only use line numbers if no context is available.
        elif self._context is None and other._context is None:
            return self._lineno == other._lineno
        else:
            return True

    def __hash__(self):
        """Return a fast hash.

        The hash only includes the lineno if no context is present. If a context is
        present, it is used instead and the line number is not included in the hash. This
        convention is compatible with the code in __eq__.
        """
        if self._context is None:
            return hash((self._filename, self._lineno, self._charno, self._text))
        else:
            return hash((self._filename, self._charno, self._text, self._context))

    def __lt__(self, other):
        """Test if one Message is less than another."""
        if self.__class__ != other.__class__:
            return self < other
        tup_self = (self._filename, self._lineno, self._charno, self._text, self._context)
        tup_other = (other._filename, other._lineno, other._charno, other._text, other._context)
        return tup_self < tup_other

    def add_context(self, context):
        """Return an identical Message with context."""
        if self._context is not None:
            raise ValueError('This message already has context.')
        return Message(self._filename, self._lineno, self._charno, self._text, context)

    def __str__(self):
        """Return a nicely formatted string representation of the message."""
        # Fix the location string
        if self.filename is None:
            location = '(nofile)            '
        else:
            location = str(self.filename)
            location += '{:>6}'.format('' if self.lineno is None else self.lineno)
            location += '{:>6}'.format('' if self.charno is None else self.charno)
        return '{0:>70s}   {1}' % (location, self.text)

    def indiff(self, files_lines):
        """Test if Message occurs in git diff results by chcking the line numbers.

        Parameters
        ----------
        files_lines : dict
            Dictionary of filename to the set of line numbers (that have been modified)
            Result of git diff from rundiff function
        """
        line_numbers = files_lines.get(self._filename)
        return line_numbers is not None and self._lineno in line_numbers


def run_command(command, verbose=True, cwd=None, has_failed=None):
    """Run command as subprocess with default settings suitable for trapdoor scripts.

    Parameters
    ----------
    command : list of str
        The command argument to be passed to Popen.
    verbose : bool
        When set to False, the command will not be printed on screen.
    cwd : str
        The working directory where the command is executed.
    has_failed : function(returncode, stdout, stderr)
        A function that determines if the subprocess has failed. The default
        behavior is to check for a non-zero return code.

    Returns
    -------
    output : (str, str)
        if Sucessful, the output collected from stdout and stderr are returned.

    Raises
    ------
    In case the subprocess returns a non-zero exit code, the stdout and stderr are printed
    on screen and RuntimeError is raised.
    """
    # Functions to detect failure
    def default_has_failed(returncode, stdout, stderr):
        """Default function to detect failed subprocess."""
        return returncode != 0
    if has_failed is None:
        has_failed = default_has_failed

    if verbose:
        print('RUNNING            : {0}'.format(' '.join(command)))
    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
    stdout, stderr = proc.communicate()
    if has_failed(proc.returncode, stdout, stderr):
        print('STDOUT')
        print('------')
        print(stdout)
        print('STDERR')
        print('------')
        print(stderr)
        raise RuntimeError('Subprocess returned non-zero exit status %i' % proc.returncode)
    else:
        return stdout, stderr


def linter_cppcheck(lintconfig, files_lines):
    """Linter for cppcheck.

    Parameters
    ----------
    lintconfig : str
        File for configuring cppcheck
        Not supported
    files_lines : dict
        Dictionary of filename to the set of line numbers (that have been modified)
    """
    # Get version
    print('USING VERSION      :  {0}'.format(run_command(['cppcheck',
                                                          '--version'], verbose=False)[0].strip()))

    # Get the cpp filenames
    filenames = [filename for filename in files_lines
                 if filename[filename.rfind('.'):] in ['.h', '.h.in', '.cpp', '.c']]

    messages = set([])
    if len(filenames) > 0:
        # Call Cppcheck
        command = (['cppcheck'] + filenames +
                   ['-q', '--enable=all', '--language=c++', '--std=c++11', '--xml',
                    '--suppress=missingIncludeSystem', '--suppress=unusedFunction'])
        xml_str = run_command(command)[1]
        etree = ElementTree.fromstring(xml_str)

        # Parse the output of Cppcheck into standard return values
        for error in etree:
            if 'file' not in error.attrib:
                continue
            # key = '{:<15}  {:<40}  {:<30}' % (error.attrib['severity'],
            #                                   error.attrib['file'],
            #                                   error.attrib['id'])
            text = '{} {} {}' % (error.attrib['severity'], error.attrib['id'], error.attrib['msg'])
            messages.add(Message(error.attrib['file'], int(error.attrib['line']), None, text))
    return messages


LINTERS = {
    'cppcheck': linter_cppcheck
}


if __name__ == '__main__':
    main()
